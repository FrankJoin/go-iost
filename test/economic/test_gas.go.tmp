package main

import (
	"fmt"
	"time"
)

/*
import (
	"context"
	"fmt"
	"github.com/iost-official/go-iost/account"
	"github.com/iost-official/go-iost/common"
	"github.com/iost-official/go-iost/core/tx"
	"github.com/iost-official/go-iost/crypto"
	"github.com/iost-official/go-iost/iwallet"
	"github.com/iost-official/go-iost/rpc"
	"google.golang.org/grpc"
	"time"
)
*/
/*
var server = "127.0.0.1:30002"
var conn *grpc.ClientConn

func getAccount(k string) *account.Account {
	acc, err := account.NewAccount(common.Base58Decode(k), crypto.Ed25519)
	if err != nil {
		panic(err)
	}
	return acc

}

func getTestAccount() *account.Account {
	return getAccount("4nXuDJdU9MfP1TBY1W75o6ePDZNFuQ563YdkqVeEjW92aBcE6QDtFKPFWRBeKP8uMZcP7MGjfGubCLtu75t4ntxD")
}

func getGasAccount() *account.Account {
	return getAccount("2yquS3ySrGWPEKywCPzX4RTJugqRh7kJSo5aehsLYPEWkUxBWA39oMrZ7ZxuM4fgyXYs2cPwh5n8aNNpH5x2VyK1")
}

func getRootAccount() *account.Account {
	return getAccount("1rANSfcRzr4HkhbUFZ7L1Zp69JZZHiDDq5v7dNSbbEqeU4jxy3fszV4HGiaLQEyqVpS1dKT9g7zCVRxBVzuiUzB")
}

func send(action tx.Action, acc *account.Account) {
	trx := tx.NewTx([]*tx.Action{&action}, [][]byte{}, 3000, 1, time.Now().Add(time.Second*time.Duration(5)).UnixNano())
	stx, err := tx.SignTx(trx, acc)
	if err != nil {
		panic(err)
	}
	client := rpc.NewApisClient(conn)
	res, err := client.SendRawTx(context.Background(), &rpc.RawTxReq{Data: stx.Encode()})
	if err != nil {
		panic(err)
	}
	time.Sleep(time.Duration(5) * time.Second)
	resp, err := client.GetTxReceiptByTxHash(context.Background(), &rpc.HashReq{Hash: common.Base58Encode([]byte(res.Hash))})
	if err != nil {
		panic(err)
	}
	if tx.StatusCode(resp.TxReceiptRaw.Status.Code) != tx.Success {
		panic(resp.TxReceiptRaw.String())
	}
}

func transferFromRoot(acc *account.Account, amount int64) {
	action := tx.NewAction("iost.system", "Transfer",
		fmt.Sprintf(`["%s","%s",%d]`, getRootAccount().ID, getTestAccount().ID, amount))
	send(action, getRootAccount())
}

func pledge(account *account.Account, amount int64) {
	action := tx.NewAction("iost.gas", "PledgeGas", fmt.Sprintf(`["%s", %d]`, account.ID, amount))
	send(action, account)
}

func unpledge(account *account.Account, amount int64) {
	action := tx.NewAction("iost.gas", "UnpledgeGas", fmt.Sprintf(`["%s", %d]`, account.ID, amount))
	send(action, account)
}

func checkBalance(acc *account.Account, amount int64) {
	info, err := iwallet.GetAccountInfo(server, acc.ID, true)
	balance := info.Balance
	if err != nil {
		panic(err)
	}
	if amount != balance {
		fmt.Printf("check failed. balance %d, expected %d\n", balance, amount)
	}
}

func getGas(acc *account.Account) string {
	info, err := iwallet.GetAccountInfo(server, getTestAccount().ID, true)
	if err != nil {
		panic(err)
	}
	return info.Gas
}

// the function simulate a pledge-then-unpledge operation. Now the function is run/tested manually.
func scenario1() {
	transferFromRoot(getTestAccount(), 5000)
	//checkBalance(getTestAccount(), 5000)
	checkBalance(getGasAccount(), 0)
	pledge(getTestAccount(), 200)
	//checkBalance(getTestAccount(), 4800)
	checkBalance(getGasAccount(), 200)
	i := 0
	for i < 15 {
		i++
		fmt.Printf("gas: %v\n", getGas(getTestAccount()))
		time.Sleep(time.Duration(3) * time.Second)
	}
	unpledge(getTestAccount(), 100)
	//checkBalance(getTestAccount(), 4900)
	checkBalance(getGasAccount(), 100)
	i = 0
	for i < 5 {
		i++
		fmt.Printf("gas: %v\n", getGas(getTestAccount()))
		time.Sleep(time.Duration(3) * time.Second)
	}
}

func tmp() {

}
*/
func main() {
	ticker := time.NewTicker(time.Second * 3)

	//var offset int64 = 100
	//largestSeq, _ := models.LatestEtTransferLog()
	//pos := largestSeq + offset + 1
	//maxSeq := largestSeq

	for range ticker.C {
		fmt.Println("hah")
	}

		/*
		var err error
		conn, err = grpc.Dial(server, grpc.WithInsecure())
		if err != nil {
			panic(err)
		}
		scenario1()
		*/
}
